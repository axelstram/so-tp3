\section{Map-Reduce}

Intro de esta parte

\subsection{Ejercicio 1}

La consigna de este ejercicio es encontrar el encontrar el subreddit con mayor score promedio.

\subsubsection{C\'odigo Map-Reduce}

El c\'odigo implementado es:

\textbf{Map:}

\begin{lstlisting}
function() {
    emit(this.subreddit, {
    	score: this.score,
    	submision: 1
    });
}

\end{lstlisting}

La funci\'on Map, "mapea"  la entrada en tuplas, que tienen por clave el subreddit de la submisi\'on, y por valor el puntaje de la submisi\'on de entrada, y adem\'as en el valor se agrega el campo submisi\'on de valor 1, contando la sumisi\'on actual que el Map est\'a procesando.

\vspace{2mm}

\textbf{Reduce:}

\begin{lstlisting}

reduce (key, values){
   reducedValue = {score:0, submision: 0}

    var total_score = 0;

	for(i = 0; i < values.length; i++) {
		total_score += values[i].score;
	}

	reducedValue.score = total_score;
	reducedValue.submision = values.length;

    return reducedValue;
}

\end{lstlisting}

La funci\'on reduce toma las tuplas intermedias salida del Map, y para cada clave suma los puntajes de todas sus submisiones, y guarda la cantidad de \'estas, de forma de poder calcular el promedio. Sin embargo, el c\'alculo de promedio debe delegarse a la siguiente instancia, para que la funci\'on Reduce siga siendo asociativa, conmutativa e idempotente, lo cual cumple porque se compone de una sumatoria.

\vspace{2mm}

\textbf{Finalize:}

\begin{lstlisting}

finalize (key, reducedValue) {
  reducedValue.avg = reducedValue.score / reducedValue.submision;
  return reducedValue.avg;
}

\end{lstlisting}

Es necesario la inclusi\'on de una funci\'on $Finalize$ que modifice la salida de la funci\'on Reduce, de forma de poder calcular el promedio. Si deleg\'aramos la tarea en la funci\'on reduce, dejar\'ia de ser v\'alida ya que el c\'alculo del promedio no es \textbf{asociativo} ni \textbf{conmutativo} por la presencia de una divisi\'on.

\vspace{2mm}

\subsubsection{Query en la base de datos}


\begin{lstlisting}
db.ej1.find().sort({"value.avg":-1}).limit(1)
\end{lstlisting}

Realizamos un $find()$, que devuelve todos los documentos de la colecci\'on, y aplicamos la funci\'on $sort()$ en cuanto al promedio de forma descendiente, para tomar el primer elemento con $limit(1)$. Con fines did\'acticos, nos tomamos la libertad de aplicar $limit(5)$, de forma de obtener el top 5 y poder comparar mejor.

\begin{enumerate}

\item Subreddit: \textbf{WTF}, Promedio: \textbf{1244145} 
\item Subreddit: \textbf{gifs}, Promedio: \textbf{154294}  
\item Subreddit: \textbf{funny}, Promedio: \textbf{119566}  
\item Subreddit: \textbf{pics}, Promedio: \textbf{54924}  
\item Subreddit: \textbf{aww}, Promedio: \textbf{49331}  


\end{enumerate}

Por lo que el subreddit con mayor puntaje promedio es \textbf{WTF}.

\subsection{Ejercicio 2}

La consigna de este ejercicio es encontrar los doce t\'itulos con mayor score de la colecci\'on de posts con al menos 2000 votos.

\subsubsection{C\'odigo Map-Reduce}

El c\'odigo implementado es:

\textbf{Map:}

\begin{lstlisting}
map() {
		emit(this.title, {
    	score: this.score,
    	votes: this.total_votes
    });
}
\end{lstlisting}

Se mapea la entrada en tuplas $Clave:$ t\'itulo y $Valor:$ puntaje y votos, de forma de poder relacionar cada t\'itulo con su puntaje y cantidad de votos, para el posterior ordenado y filtrado.

\vspace{2mm}

\textbf{Reduce:}

\begin{lstlisting}
reduce (key, values){
	reducedValue = {score : 0, votes : 0}
	
	var total_score = 0;
	var total_votes = 0;

	for(i = 0; i < values.length; i++) {
		total_score += values[i].score;
		total_votes += values[i].votes;

	}

	reducedValue.score = total_score;
	reducedValue.votes = total_votes;

    return reducedValue;
}

\end{lstlisting}

Una vez terminadas las etapas de Map y Shuffle, la funci\'on reduce toma las tuplas y para cada t\'itulo suma el puntaje total y la cantidad total de votos, y devuelve la tupla (puntaje,votos) como valor. Cabe aclarar que dicha funci\'on es asociativa, commutativa e idempotente dado que se compone de dos sumatorias.

\vspace{2mm}

\subsubsection{Query en la base de datos}

El procesamiento MapReduce nos da como resultado un conjunto de tuplas $\{titulo, \{ puntaje, votos \}\}$. Ahora nos queda encontrar aquellos t\'itulos con m\'as de 2000 votos, ordenarlos por puntaje y devolver los doce primeros. Esto lo realizamos mediante un $query$ de la base de datos MongoDB, de la siguiente forma:

\vspace{2mm}

\begin{lstlisting}
db.ej2.find({"value.votes":{$gt:2000\}}).sort({"value.score":-1}).limit(12)
\end{lstlisting}

Dividi\'endolo en pasos:

\begin{itemize}

\item \textbf{db.ej2.find(\{"value.votes":\{\$gt:2000\}\})}: se aplica la funci\'on find() en la base de datos para buscar aquellas entradas, en las que el atributo "value.votes" sea mayor a 2000.

\item \textbf{sort(\{"value.score":-1\})}: se ordenan estos valores segu\'un el atributo "value.score", en orden descendiente.

\item \textbf{limit(12)}: tomamos los primeros 12 de la query

\end{itemize}

\vspace{2mm}

Finalmente, los doce t\'itulos con mayor score de la colecci\'on de posts con al menos 2000 votos son:

\begin{enumerate}

\item \textbf{"The Bus Knight"} score: 21953
\item \textbf{"Haters gonna hate"} score: 14098
\item  \textbf{"So my little cousin posted on FB that he was bored and gave everyone his new phone number... (pic)"} score: 12333
\item \textbf{"My friend calls him Mr Ridiculously Photogenic Guy"} score: 11908
\item \textbf{"This is called humanity."} score: 10263
\item \textbf{"Genius"} score: 9980
\item \textbf{"Seems legit."} score: 9530
\item \textbf{"President Obama's new campaign poster"} score: 8942
\item\textbf{"Poster ad for the Canadian Paralympics"} score: 8752
\item \textbf{"Fuck the police"} score: 8764
\item \textbf{"Soon..."} score: 8669
\item \textbf{"I'm sorry pinata bro"} score: 8314

\end{enumerate}

\subsection{Ejercicio 3}

\subsubsection{C\'odigo Map-Reduce}

El c\'odigo implementado es:

\textbf{Map:}

\begin{lstlisting}

\end{lstlisting}


\vspace{2mm}

\textbf{Reduce:}

\begin{lstlisting}

\end{lstlisting}


\vspace{2mm}

\subsubsection{Query en la base de datos}


\subsection{Ejercicio 4}

La consigna de este ejercicio es, entre los usuarios con a la sumo 5 sumisiones, encontrar el que posea mayor cantidad de
upvotes.

\subsubsection{C\'odigo Map-Reduce}

El c\'odigo implementado es:

\textbf{Map:}

\begin{lstlisting}
map() {
    emit(this.username, {
    	upvotes: this.number_of_upvotes,
    	submision: 1
    });
}
\end{lstlisting}

Se mapea la entrada en tuplas $Clave:$ usuario y $Valor:$ upvotes, y adem\'as en el valor se agrega el campo submisi\'on de valor 1, representando la sumisi\'on actual que el Map est\'a "mapeando", valga la redundancia. Esto nos permite relacionar cada usuario con su cantidad de upvotes, y contar 1 por cada sumisi\'on, que luego se encargar\'a de sumar la funci\'on Reduce.


\vspace{2mm}

\textbf{Reduce:}

\begin{lstlisting}
Reduce (key, values){
reducedValue = {upvotes : 0, submision : 0}
	
	var total_upvotes = 0;
	var total_submisiones = 0;

	for(i = 0; i < values.length; i++) {
		total_upvotes += values[i].upvotes;
	}

	reducedValue.upvotes = total_submisiones;
	reducedValue.submision = values.length;

    return reducedValue;
}
\end{lstlisting}

\vspace{2mm}

La funci\'on Reduce toma las tuplas, y al igual que la del ejercicio anterior, suma las componentes $upvotes$ del conjunto de valores de la clave, y por \'ultimo, la cantidad de \'estos valores es la cantidad de submisiones de dicho usuario. La funci\'on, al igual que la del anterior ejercicio cumple con las propiedades requeridas por componerse de sumatorias.

\subsubsection{Query en la base de datos}

El procesamiento MapReduce nos da como resultado un conjunto de tuplas $\{usuario, \{ upvotes, submisiones \}\}$. Ahora nos queda encontrar aquellos usuarios con 5 o menos submisiones, ordenarlos por upvotes y mostrar el ganador. Esto lo realizamos mediante un $query$ de la base de datos MongoDB, de la siguiente forma:

\vspace{2mm}

\begin{lstlisting}
db.ej4.find({"value.submisiones":{$lt:6\}}).sort({"value.upvotes":-1}).limit(1)
\end{lstlisting}

Dividi\'endolo en pasos:

\begin{itemize}

\item \textbf{db.ej4.find(\{"value.submisiones":\{\$\{lt:6\}\})}: se aplica la funci\'on find() en la base de datos para buscar aquellas entradas, en las que el atributo "value.votes" sea menor estricto a 6.

\item \textbf{sort(\{"value.upvotes":-1\})}: se ordenan estos valores segu\'un el atributo "value.score", en orden descendiente.

\item \textbf{limit(1)}: tomamos el primero.

\end{itemize}

Con prop\'ositos did\'acticos, reemplazamos la funci\'on $limit(1)$ con $limit(5)$ para analizar el top 5 de usuarios.

\begin{enumerate}

\item Usuario: \textbf{lepty}, Upvotes: \textbf{90396} Submisiones: \textbf{1}
\item Usuario: \textbf{Robert\_Houdin}, Upvotes: \textbf{67767} Submisiones: \textbf{1}
\item Usuario: \textbf{RuffDesperado}, Upvotes: \textbf{64987} Submisiones: \textbf{1}
\item Usuario: \textbf{frackyou}, Upvotes: \textbf{63392} Submisiones: \textbf{1}
\item Usuario: \textbf{dwerb99}, Upvotes: \textbf{62048} Submisiones: \textbf{1}

\end{enumerate}

Por lo que el usuario con a lo sumo 5 submisiones y mayor cantidad de upvotes es \textbf{lepty}.

\subsection{Ejercicio 5}

La consigna de este ejercicio es, para todos los subrredit que poseen un score ente 280 y 300, indicar la cantidad palabras presentes en sus t\'itulos.

\subsubsection{C\'odigo Map-Reduce}

El c\'odigo implementado es:

\textbf{Map:}

\begin{lstlisting}
map() {

	var cantPalabras = this.title.split(' ').length;

    emit(this.subreddit, {
    	score: this.score,
    	words: cantPalabras
    });
}

\end{lstlisting}

Se mapea la entrada en tuplas $Clave:$ subreddit y $Valor:$ puntaje, cantidad de palabras. El c\'alculo de la cantidad de palabras se realiza mediante la funci\'on $split()$ de $Javascript$, que toma el string del t\'itulo y lo divide en un array de substrings, usando como delimitador el caracter espacio. De esta forma, luego pedimos la longitud de dicho array, y obtenemos la cantidad de palabras del t\'itulo. Este mapeo nos permite relacionar cada usuario con su puntaje, y la cantidad de palabras presente en el t\'itulo de la submisi\'on actual.

\vspace{2mm}

\textbf{Reduce:}

\begin{lstlisting}
reduce (key, values){
    reducedValue = {score: 0, words: 0};

	var total_score = 0;
	var total_palabras = 0;

	for(i = 0; i < values.length; i++) {
		total_score += values[i].score;
		total_palabras += values[i].words;
	}

	reducedValue.score = total_score;
	reducedValue.words = total_palabras;


    return reducedValue;
}

\end{lstlisting}

La funci\'on reduce, similar a las de ejercicios anteriores, se limita a sumar para cada clave sus valores, su puntaje y las cantidad de palabras de todas sus submisiones.

\vspace{2mm}

\subsubsection{Query en la base de datos}

\begin{lstlisting}
db.ej5.find({"value.score":{$lt:301,$gt:279\}})
\end{lstlisting}

Con la funci\'on $find()$ encontramos todas las tuplas y filtramos las que tienen puntaje menor estricto a 301 y mayor estricto a 279. No hace falta m\'as, ya que esto nos provee las tuplas:

\begin{enumerate}

\item Subreddit: \textbf{Feminism}, Puntaje: \textbf{282} Palabras: \textbf{6}
\item Subreddit: \textbf{Firearms}, Puntaje: \textbf{281} Palabras: \textbf{24}
\item Subreddit: \textbf{HeroesofNewerth}, Puntaje: \textbf{287} Palabras: \textbf{6}
\item Subreddit: \textbf{Sexy}, Puntaje: \textbf{293} Palabras: \textbf{13}
\item Subreddit: \textbf{TheRealZachAnner}, Puntaje: \textbf{286} Palabras: \textbf{4}
\item Subreddit: \textbf{anime}, Puntaje: \textbf{300} Palabras: \textbf{18}
\item Subreddit: \textbf{ragecomics}, Puntaje: \textbf{283} Palabras: \textbf{4}
\item Subreddit: \textbf{xkdc}, Puntaje: \textbf{288} Palabras: \textbf{4}

\end{enumerate}